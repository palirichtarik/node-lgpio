<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [lgpio](./lgpio.md) &gt; [txServo](./lgpio.txservo.md)

## txServo() function

This starts software timed servo pulses on an output GPIO.

**Signature:**

```typescript
export declare function txServo(handle: number, gpio: number, pulseWidth: number, servoFrequency: number, servoOffset?: number, servoCycles?: number): number;
```

## Parameters

<table><thead><tr><th>

Parameter


</th><th>

Type


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

handle


</td><td>

number


</td><td>

The GPIO device handle as returned by [gpiochipOpen()](./lgpio.gpiochipopen.md)


</td></tr>
<tr><td>

gpio


</td><td>

number


</td><td>

The GPIO number


</td></tr>
<tr><td>

pulseWidth


</td><td>

number


</td><td>

Pulse high time in microseconds (0=off, 500-2500)


</td></tr>
<tr><td>

servoFrequency


</td><td>

number


</td><td>

The number of pulses per second (40-500)


</td></tr>
<tr><td>

servoOffset


</td><td>

number


</td><td>

_(Optional)_ Offset from nominal pulse start position


</td></tr>
<tr><td>

servoCycles


</td><td>

number


</td><td>

_(Optional)_ The number of pulses to be sent, 0 or unspecified for infinite


</td></tr>
</tbody></table>

**Returns:**

number

The number of entries left in the PWM queue for the GPIO

## Remarks

I would only use software timed servo pulses for testing purposes. The timing jitter will cause the servo to fidget. This may cause it to overheat and wear out prematurely.

Each successful call to this function consumes one PWM queue entry.

Another servo command may be issued to the GPIO before the last has finished.

If the last pulse had infinite cycles then it will be replaced by the new settings at the end of the current cycle. Otherwise it will be replaced by the new settings when all its cycles are compete.

Multiple servo settings may be queued in this way.

